# Python<br>Codage de César

Le principe du codage de César est le remplacement d'un caractère par un caractère à une distance fixe. Pour les dernières lettres (dans le cas d'un décalage à droite), on reprend au début.

Les fonctions `chr` et `ord` seront très utiles !

## Premiers exemples sans ordinateur ...

**1)** On utilise ici l'alphabet (en lettre majuscule) et on souhaite faire un décalage vers la droite de 5 caractères. Ainsi `A` est remplacé par `F`. On peut s'aider d'un tableau :  

|  A  |  B  |  C  |  D  |  E  |  F  |  G  |  H  |  I  |  J  |  K  |  L  |  M  |  N  |  O  |  P  |  Q  |  R  |  S  |  T  |  U  |  V  |  W  |  X  |  Y  |  Z  |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|  F  |  G  |  H  |  I  |  J  |  K  |  L  |  M  |  N  |  O  |  P  |  Q  |  R  |  S  |  T  |  U  |  V  |  W  |  X  |  Y  |  Z  |  A  |  B  |  C  |  D  |  E  |

**2)** En utilisant la méthode précédente, comment est codé le mot "RAZ DE MAREE" ?  
**3)**  Si `A` est associé au nombre 0, `B` est associé au nombre 1, ..., construire le tableau de la méthode précédente avec les nombres associés aux caractères :  

|  0  |  1  |  2  | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 5 | 6 | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... |

**4)**  Pour un décalage de 5 vers la droite, l'opération immédiate est d'ajouter 5 à l'indice du caractère. Mais pour les derniers, on obtient des nombres qui dépasse 26 ! Ainsi, on cherche une &laquo; opération &raquo; qui  

    - à 5 associe 5
    - à 6 associe 6
    - ...
    - à 25 associe 25
    - à 26 associe 0
    - à 27 associe 1
    - ...
    - à 30 associe 4  
En utilisant vos connaissances sur les différentes &laquo; opérations informatiques &raquo;, laquelle semble convenir ?

## .... Et avec ordinateur


**5)**  Ecrire la fonction `creer_alphabet` qui renvoie une chaine de caractères comportant l'alphabet **en majuscule**.  
Signature `fonction creer_alphabet() : str`  
Ainsi, `creer_alphabet()` renvoie `ABCDEFGHIJKLMNOPQRSTUVWXYZ`.  
**6)**  Ecrire une fonction `mon_ord` qui prend en argument une lettre majuscule et qui renvoie l'indice associé (comme dans l'exemple précédent).  
Signature `fonction mon_ord(car : str) : int`  
Ainsi, `mon_ord('C')` renvoie 2 !  
**7)**  Ecrire une fonction `mon_chr` qui prend en argument un entier entre 0 et 25 (inclus) et qui renvoie la lettre majuscule associée (comme dans l'exemple précédent).  
Signature `fonction mon_chr(idx : int) : str`.  
Ainsi, `mon_chr(2)` renvoie `'C'` !  
**8)**  Ecrire une fonction `nvx_car` qui prend en argument une lettre majuscule `car` et entier `decal` et qui renvoie le caractere associé à `car` après un decalage de `decal` (decalage vers la droite si `decal` est positif et vers la gauche sinon).  
Signature `fonction nvx_car(car : str, decal : int) : str`  
Par exemple, `nvx_car('A',5)` renvoie `F` !  
**9)**  Ecrire la fonction `code_simple` qui code un message selon un décalage précisé en argument. **Attention :** seules les lettres (qui seront des majuscules) seront codées. Les autres caractères ne seront pas modifiés.  
Signature `fonction code_simple(message : str, decal : int) : str`  
Par exemple, `code_simple("BONJOUR. VIVE L'INFORMATIQUE !", 10)` renvoie `LYXTYEB. FSFO V'SXPYBWKDSAEO !`  
**10)**  Ecrire une fonction `decode_simple` qui décode un message en connaissant le décalage utilisée.  
Signature : `fonction decode_simple(mess_code : str, decal : int) : str`  
Par exemple, `decode_simple("QF XQE YMFTQYMFUCGQE !", 12)` renvoie `ET LES MATHEMATIQUES !`  
*Astuce* : utiliser la fonction `code_simple`.  

## Décryptage

Décrypter un message codé par la méthode de César consiste à découvrir le texte en clair **sans connaitre** le décalage associé !  
Une méthode consiste à établir la fréquence des caractères cryptés et d'utiliser la fréquence des caractères dans une langue donnée. Il est alors facile de trouver le décalage.

Nous ferons cela dans un autre TP avec des tableaux !

## Améliorations

On souhaite maintenant coder tous les caractères dont l'entier associé est compris entre `32` et 
`126` (inclus).

**11)** En reprenant le *TP gestionnaire de mot de passe*, quels caratères pourront être utilisés ? Quels caractères ne pourront pas être codés ? Quelle langue (européenne) semble particulièrement adaptée à ces conditions ?  

### Utilisation d'un copier-coller

**12)** Copier-coller les codes précédents et modifier les fonctions afin de pouvoir coder **tous les caractères** du message suivant :  

*I say to the House as I said to ministers who have joined this government, I have nothing to offer but blood, toil, tears, and sweat. We have before us an ordeal of the most grievous kind. We have before us many, many months of struggle and suffering.You ask, what is our policy? I say it is to wage war by land, sea, and air. War with all our might and with all the strength God has given us, and to wage war against a monstrous tyranny never surpassed in the dark and lamentable catalogue of human crime. That is our policy.*

### Une meilleure façon de faire

Il est préférable de modifier les fonctions en passant en paramètres les éléments qu'il faut adapter selon les situations.  
Voici les nouvelles signatures :

- `Fonction creer_alphabet(idx_deb : int, idx_fin : int)`
- `Fonction mon_ord(car : str, idx_deb : int, idx_fin : int)`
- `Fonction mon_chr(car : str, idx_deb : int, idx_fin : int)`
- `Fonction nvx_car(car : str, decal : int, idx_deb : int, idx_fin : int)`
- `Fonction code_simple(message : str, decal : int, idx_deb : int, idx_fin : int)`
- `Fonction decode_simple(mess_code : str, decal : int, idx_deb : int, idx_fin : int)`

**13)** Modifier les fonctions en conséquences.  
**14)** En utilisant les caractères dont les entiers associés sont compris entre `32` et `126` (inclus), coder le message précédent.  
**15)** On ne souhaite pas coder les espace : en utilisant les caractères dont les entiers associés sont compris entre `33` et `126` (inclus), coder le message précédent.  
**16)** En utilisant les caractères dont les entiers associés sont compris entre `65` et `122` (inclus), coder le message précédent.

